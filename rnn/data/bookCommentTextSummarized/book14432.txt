https://www.goodreads.com/book/show/43713.Structure_and_Interpretation_of_Computer_Programs
It's worthy to note that the first 2 chapter (out of 5) don't even introduce state.
The final step is writing a compiler that compiles Scheme code to primitive instructions.The cherry on the pie is the last three exercises.
First you have to compile your Scheme interpreter to the register machine simulator.
Finally, you modify the compiler to generate C code and compile the interpreter, resulting to a Scheme implementation on C.Apart from fun, the material is a great introduction to a wide variety of topics.
If you just want to have a sense about computer science, this is a great book.
(Disclosure: my study group skipped ~10 exercises).The second similarity to the Bible is that many who champion this book don't seem to have read it!
(Proponents could argue this is great preparation for real software shops but in a textbook it was a hinderance.) There are even a few times where it contradicts itself.Similarities aside, SICP explores the underlying ideas of computation and mixes computer science and philosophy in ways that were mind-expanding or captivating.
At times SICP is a genuinely mind-expanding book that shows you new ways of thinking about computation.
I read this on the advice of Dr. Eiselt, Dean (at that time) of the College of Computing, after asking him via email "alright, I'm taking classes and whatnot, but I want the Stygian deep; I want to go down as far as I can; I want and need to read those books which have shaped the great computer scientists before me, the real thing." Having probed the shelves of computer science and mathematics since, I remain convinced he could have given no better advice to a precocious freshman.
Used for several decades at MIT, this second edition is more than thorough enough for an introduction to computer science anywhere.
A work of art. SICP will make you a better programmer in the same way that reading Dostoevsky will make you a better writer.
If you are a programmer or are majoring in computers in college in any shape, form, or fashion, read this book. Let me reiterate: If you're a programmer and you don't read this book you're worthless. If you're a sys admin, and you write with scripting languages to do administrative tasks, and you don't read this book, you're worthless. If you program for websites using javascript, ajax, .NET, etc., and you don't read this book, you're worthless.
What I learned from literature in that field paired with my own observations are what lead me to eventually realize this book is not appropriate for an introductory course.
Professors tend to disproportionately be motivated in this fashion, and I think this accounts for popularity of this book.This is not a majority of people however, this is not even a majority of students who graduate with Computer Science degrees.
What I am trying to say ultimately is that I think this is a must read book for computer science students, but I think it would be more appropriate for half of a junior level course on programming paradigms than the whole of an introductory course on programming more generally.
Twenty hours of video lecture by Abelson and Sussman are available through MIT Open CourseWare, though it is worth noting that these classes used the first edition of the textbook.
Imagine two sophomore computer science majors in a dorm room late at night.
One of them, possibly under the influence of a recently decriminalized substance, turns to the other and asks, "Have you ever thought about what a computer program is.
I mean, have you ever *really* thought about it?"This book is a good answer to that question.
The title is apt, it really is about the structure and interpretation of computer programs.
It's an enlightening read, but I write this as somebody who has been programming for twenty years now.
It's hard for me to imagine how a novice would react to this sort of book.
Downloadable PDF version here:https://github.com/sarabander/sicp-pd...
One of the most inspiring computer books I ever read.
Brilliantly written, it almost makes you want to read it like a "normal" book.
The AI course I took only required to read a few parts of it, but I continued reading this book instead of other things I was supposed to read.
(I gave it credits for the A I actually got.
:))It's not just about LISP, really.
It teaches you about a powerful, expressive tool (LISP) but it goes beyond simple syntax and shows you how to actually phrase the problem correctly in order to solve it in the easiest, most elegant way.
I loved programming more after reading this book.
In an ideal world, everybody learns Scheme as their first programming language and knows recursion, lambda, closure and multi-paradigm programming as his/her first step to programming.
The Berkeley videos at YouTube makes the lectures freely available on the web, which are really helpful for reading this book.The book is a wonderful exposure of the fundamentals of functional programming way of thinking, providing complete implementation of all the algorithms in Scheme.
As the book goes on, more and more and the technical details are revealed and in the end everything just makes sense.I feel lucky that I read the book.
Если коротко, то просто замечательная книга. Обязательна для прочтения любому программисту. Начинается от основ построения абстракций с просто отличными примерами, после чего сложность плавно нарастает заканчивается построением модели вычислительной машины с написанием лисп интерпретатора и компилятора под нее, что объясняет множество нюансов работы реальных интерпретаторов и компиляторов, при этом не захламляя повествование деталями.О переводе: Читал книгу на русском, перевод издательства Добросвет. Это определенно лучший перевод компьютерной литературы который я видел. Все термины аккуратно переведены, никаких англицизмов, кроме того, автор полностью понимал, о чем он пишет (что в переводах, к сожалению, встречается не всегда)
I didn't think this was a good book for teaching young people how to become programmers when I first read it and I think it is even less true today.
First off: I think this is a book that people who have forgotten what it was like to learn programming tend to recommend.
Nobody I know started with material like SICP -- they wrote programs, ran into unknown problems and then were motivated to hit the books before hammering out more code.Which brings us to my second reason: today kids don't hit the books.
This book will be a hard sell.People learn to program because they want to write software.
This book really lives up to its reputation, and is still astoundingly relevant considering it's 30 years old.The first three chapters are an introduction to programming in scheme, but they contain enough interesting material to make them worthwhile even for programmers with experience in Lisp-like languages.The last two chapters, however, are where the book really shines.
The interpreter is then extended to provide lazy and nondeterministic evaluation, and to enable logic programming.Chapter 5 describes a register machine simulator and a compiler from scheme to machine code that runs on the simulator.
There are tons of exercises in this book, and a remarkable percentage of them is actually interesting and provides deeper understanding of the topics covered in the book.
It teaches foundations of lasting value in an elegant machine language that has been around in one form or another since the 1950s.Whilst the material gets impressively advanced just a couple of chapters in, I'd also recommend this book to friends who've never written code before.
This could be followed by a curious novice in much the same way that a coffee table book of crosswords or logic puzzles could be followed recreationally..
this is the kind of book that makes computing simple and fresh again even for experienced professionals, teaching some deep topics as it does so.
The real gems in the book are in the exercises contained within. I enjoyed reading about evaluation models and scope, streams (especially modelling time in streams vs oop), merging streams, and the power of composition (circuit design, constraint calculation programs). After starting this book, I've been trying to capture common patterns I see in my day to day programming and I do believe I've gotten a lot better at it. In any case, my vocabulary for talking about problems has improved and I'm much more mindful of program state.
This is one of those books that changes you. If I could save only one computer science book from destruction, this would be it. The book features LISP, but the insights are universal.I had the fortune to take my first computer science course with Brian Harvey, who helped digest some of the trickier ideas in the book.It's been 10 years; I have to re-read it.
If I could go back and tell myself where to start with computer science, this would have been it. It may be a little tough for beginners, but I feel that if you know enough to get through the first chapter or so, you will be set.
A classic book to understand programming. Loved reading it and also the lectures on ocw.mit.edu! Would also recommend Randy Bryant's "Computer Systems" and "How to Design Programs" by Matthias Felleisen, et.al,
đỉnh
I had some real quality time debugging through multiple layers of interpretation only to discover that I actually had to return a list of one element instead of the element itself.Or, maybe just use statically typed language that eliminates problems like these at compile time.
I did not enjoy reading the last chapter though which was a mire of the technical details of interpreters and compilers, this part of the book took away from the beautiful presentation of the general high level ideas of how computer programs should be structured and instead provided dull concrete examples of how to implement a interpreter and compiler - neither of which I cared for.Lisp is often seen as being quite a mythical language and while powerful and interesting to program in - it is esoteric.
Things that other languages take as granted (such as dynamic dispatch of methods) are analyzed in detail I haven't seen anywhere else in one place.
That all said, the book is still quite approachable and it should be easy to understand for anyone with elementary knowledge of computing and mathemtaics.The only downside is that the style is a bit dry, which makes the book less enjoyable if you already know most of the concepts e.g. from university lectures or from other books.
But even so it is a worth read.
This is a fascinating book! Reading this book has made me very excited about functional programming. The authors explain complicate topics elegantly.As I got further into the book it became increasingly complex. What had started at easily my level passed what I can understand. The last chapters are very in-depth and even more powerful.Programming for many years in imperative languages meant this book explored code in new ways for me. I would definitely recommend reading it to expand you horizons. Take it slow as the book continues and try to do the examples. They are lots of fun.
Excellent book! I read only like 1/3 of it for an undergrad course. I was very happy back then when I realized that the slides that didn't make any sense at all where just excerpts from the book and the actual text was pretty good to understand.Well written, broad and deep, though not very practical (in terms of direct applicability in practice) introduction to Computer Science and especially Programming. Almost philosophical in some parts, which I liked.Have to read the whole thing one day ...
An excellent book on programming. The foundation of functional programming explained. Recursive and iterative process. Function application. Scheme.Though I read only first 2 chapters I gained so much from this book. I learned how to design procedures to solve problems through recursion. Only after reading this book I started to appreciate recursive functions. Suddenly they became foundation to solving real world problems. Divide and conquer.
This book is generally described as the best introduction to programming. I read it during 2009-2010 years and spent nearly all days of a summer fighting against exercises. And this was the first time I really enjoyed reading computer science book! I'm not going to tell you how good it is, just remember the first rule of SICP: every word in this book have it's place there for very good reasons.
fucking brilliant amaAAAZZZZZING!!!!!!!best book on generic programming - love itand if you like this, I think you should check out John Locke's Essay on Understanding Human Though. If you read the above book, you'll understand why Locke's work applies so well :)
To understand programming at a fundamental level, beyond making license plates with various languages this book is a must. Thetrue fundamentals are presented in a well structured curriculum and learning scheme is mental steroids for programmers.
This book is written for LISP programming language which is for my familiar.The first 3 chapters are normal introductions about statement, condition...The chapter 4 provide useful explanation about interpreter which is a software to interpret and execute source code.
