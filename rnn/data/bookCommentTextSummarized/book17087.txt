https://www.goodreads.com/book/show/85009.Design_Patterns
I don't like it as much as I used to, as I've found that using dynamic languages (ruby, perl, etc) made many of the design patterns unnecessary.
Still, when I first read this book it changed the way I thought about software design and I remember my friend and I frantically re-writing huge chunks of our codebase to throw in several design patterns.
I recall being amazed at seeing good, reusable solutions to problems we kept encountering.Anyways, if you're not using Java/C++/other "static" languages you probably won't find this as useful.
Still a good read, just to make you rethink some of your designs.
Perhaps it's becoming a cliche (or became one 10 years ago?), but I'm sure some haven't yet been exposed to this thought: in a decent language like Lisp, most of these design patterns are trivial.
The patterns are only there to make up for the problems with the languages of choice.For me another issue is that the idea of design patterns is firmly linked in my brain with absurd Java APIs that require me to deal with XYZManagers and ABCHandlers and twenty different classes all for something that anyone sane would have just provided a handful of simple functions for.
On the other hand, this post by Richard Gabriel is interesting:http://groups.google.com/group/comp.l...Perhaps design patterns are worth looking into after all, just not in this book.
Read to understand patterns, but please think for yourself when you code.
Some of the terms are outdated by today's coding conventions, but the principles still apply and it is a fair exercise in mentally converting between the lingo used in the book and what you may be familiar with in C#, Java, or another OOP.
One interesting aspect is that you can immediately start to see what programming patterns you're already using today in the frameworks and libraries you may be using on a daily basis.
Putting a name to these design patterns, such as Factory, Command, etc helps to identify them and understand them so you as a developer know when best to apply them to your own code.
This is mainly because the bulk of the book contains a catalog of patterns.
Like most catalogs, it works better when you come to it looking for something specific.I have two main criticisms of the patterns themselves, both of which stem more from the time the book was written than from any inherent problems with the patterns.
Instead, current belief leans more toward preferring interfaces (in the Java sense of only defining operations and not implementations) and reserves implementation inheritance for when it provides a tangible benefit.That said, most of the patterns still have a useful core, even if some of the details of pattern structure or implementation should be modified to fit better into common practice.
This is the classic software design patterns book.Much of this material is assumed knowledge in many development shops so a understanding of this book is very valuable.
However, there seems to be a design pattern mania and some developers take the information in this book a bit too literally and assume these patterns are inflexible.
This is an excellent resource for developers looking to familiarize themselves with common design techniques.This book verges on being a reference.
For more of a guide, check out "Head First Design Patterns" (see my review).
This book is a bit difficult to read and understand, but still tremendously helpful. This book helped me to fully grasp the OO programming and designs principles. One has to be careful though, because by just reading this book and applying patterns everywhere will make life even more difficult. It should only be read as a book containing examples of good OO design principles, and nothing else.
Capturing a wealth of experience about the design of object-oriented software, four top-notch designers present a catalog of simple and succinct solutions to commonly occurring design problems. Previously undocumented, these 23 patterns allow designers to create more flexible, elegant, and ultimately reusable designs without having to rediscover the design solutions themselves.
Ahhhh ... design patterns. Most software engineers have probably used several of the patterns in this book without even realizing it. Still, I found it to be a useful validation of some of my design approaches as well as a valuable resource for streamlining my design. Reading it cover to cover will put any software architect in a position to solve many design issues faster than they may have otherwise.
The examples are somewhat out of date. The code can be a bit hard to follow because of this.Some of the design patterns aren't really design patterns.You can learn the the basics from this, though, so it's useful. Just be sure to read this with some more knowledgeable programmers so they can explain when the book doesn't.
Beautiful Book for very complicated topic for developers and software architects. I liked the first chapter of introduction very much. and one of the best trends I have learned from this book is that, "You don't have to use all design patterns in the software you are making, just use what you think it is useful for the current situation and purpose of the current software you are working on now".
I got this book as part of a job which had me programming in C++.
The introduction to the book is worth a read, even if you don't quite get the significance of it.
If people would only take it seriously, I think that people could begin to get an idea of what a science of computing would really be about.
I don't say this to mean that what we commonly call OO is the "path to computer science," but the idea of inventing structures that have broad applicability in applications, and to future efforts to invent more varied computational structures.
I'd recommend this book to any Object-Oriented programmer who wants to be even remotely familiar with the approaches being used to write production systems these days...
The Design Pattern based approach to software engineering has definitely caught on, and if you aren't familiar with at least the basic patterns, *you need to be* - not only to they make logical sense, but real development teams use the pattern names often, in discussions amongst multiple developers, to describe the systems/concepts/etc being discussed.
Every time I read this book it is like peeling an onion. Layers upon layers. And yet this book is still harder to use and process than I want it to be. It has been years since I read this cover-to-cover and certainly I got more out of it this time - but this book is still just at the wrong level for what I want. Then again that's what happens when you are first to a concept - the easier/better way appears later.
Probably a fourth read:3 stars.First Read:5 stars. Although an old one, it's a very good book. Maybe the best on design patterns. The joy you feel when you read it and discover that you have implemented the solution by yourself before is really enriching.
This book is a classic, you should read through it and it should sit on your bookshelf. But you should also read something newer and more accessible on design patterns as well, I recommend Head First Design Patterns.
It's true that your need for patterns such as these depends heavily on your development stack, but love or hate, use them or don't, I believe it's critical to be familiar with them unless you plan to develop in a silo.
I've consulted this book on several occasions in my career, but never really read it from beginning to the end.It's certainly an old one - 1994 (and therefore the code examples are not all that consistent with the modern trends ex. Smalltalk), and in something as fast evolving like software engineering this one is still more than relevant and go-to book for many experienced engineers. Should be considered in every advanced object-oriented and even general software engineering course in colleges everywhere.
This is a goodbook. Not an easy read, but definitely worth it for junior/mid-level OO developer. Every design pattern is explained thoroughly, and there are even 'consequences' sections on every one, and one connecting described pattern to other patterns. If you study every pattern you will get a mountain of knowledge. The book is old. You can tell by Smalltalk and C++ examples. But its also a mountain of knowledge.
The most difficult thing in it is not to understand the patterns themselves, but the underlying object-oriented knowledge.
In other words: you won't understand patterns if you don't understand object-oriented programming.
So, in some ways, this book will teach you OOP even more than it will teach you patterns.Another drawback is in the examples.
Some of those examples may not so immediate for a 2013 web developer.That said, reading this book is still - in my opinion - a mandatory step on the way of any developer enlightenment.
The best part of this book is the description of design principles. The list of patterns (which take up most of the book) are really just concrete examples of those principles in action. You may find yourself referring to those lists in the future, however, for inspiration. Definitely useful to have around at all times as a reference.
Հզորություն էր: Հրաշալիորեն կարողացավ համակարգել իմ այսքան տարիների աշխատանքային փորձը: Բացի design pattern-ների ընտիր կատալոգ լինելուց, զարգացնում է OOP-ական աբստրակտ մտածելակերպը (օրինակ՝ հասկանում ես, թե ինչով է տարբերվում տիպը կլասից):Ու հա, գիրքը (անգլերեն օրիգինալը) հավաքված է LaTeX-ով, ինչի շնորհիվ ընթերցանության ընթացքում էսթետիկ բավականություն ես ստանում:
I used this fairly extensively as a reference guide, rather than reading it front to back. Coding without using the patterns outlined in this book is a mistake, your code will be easier to write, understand and run.
Classic in computer literature. Clear, very well structured and useful book. A must read for everyone interested in software development.
I read this book a couple of years ago and I didn't understand anything. Someday I will try Head First Design Patterns
The classic computer science book.
This one is a classic. It's a kind of book that you skim through to get an overview what's inside, and then repeatedly return to when you need something particular...
Cliche at this point. In Java some of these, like Singleton, are actually anti-patterns. Most developers with 5-10 years OO development experience should already know these anyway.
Отличная книга, для тех, кто хочет ознакомиться или закрепить знания по паттернам проектирования. Воды не так много, присутствуют адекватные примеры применения.
This book is often referred as "the bible" of design patterns. I think that's kinda true, although its a few years old.
